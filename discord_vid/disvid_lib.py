"""
A bunch of useful library functions
"""
import glob
import os
import subprocess
import sys
from install.install_ffmpeg import FFMPEG_EXE, FFPROBE_EXE

def get_audio_rate(output_options):
    """
    Gets the audio rate from output optoins
    assumes its already specified in k (e.g: 64k, 128k)
    """
    audio_index = output_options.index("-b:a") + 1
    return int(output_options[audio_index].lower().replace("k","")) * 1000


def check_nvidia():
    """
    Checks if you have an nvidia gpu installed.
    """

    args = "wmic path win32_VideoController get name"
    result = subprocess.run(args.split(), capture_output=True, check=True)
    items = result.stdout.lower().split()
    items = [item.decode("utf-8") for item in items]

    if "nvidia" in items:
        return True

    return False


def get_length(filename):
    """
    returns length of file in seconds
    """
    # fmt: off
    print(FFPROBE_EXE)
    result = subprocess.run(
        [
            FFPROBE_EXE, "-v", "error",
            "-show_entries", "format=duration",
            "-of", "default=noprint_wrappers=1:nokey=1",
            filename,
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        check=True
    )
    # fmt: on

    return float(result.stdout)


def get_index(strings, array):
    """
    gets index of any of the strings in *strings* inside array *array*
    """
    for string in strings:
        try:
            return array.index(string)
        except ValueError:
            pass
    return None


def delete_logs():
    """
    Deletes logs generated by ffmpeg2pass
    """
    file_list = glob.glob("ffmpeg2pass-*.log")
    # Iterate over the list of file_paths & remove each file.
    for file_path in file_list:
        os.remove(file_path)

    file_list = glob.glob("ffmpeg2pass-*.mbtree")
    # Iterate over the list of file_paths & remove each file.
    for file_path in file_list:
        os.remove(file_path)


def get_bitrate(target_size, length, audio_rate):
    """
    Returns target video bitrate based on target size, its length in seconds,
    and the audio bitrate in Kbps
    @target_size: Size in KByte
    @length: length in seconds
    @audio_rate: Rate in Kbits/s
    return: bitrate in Kbit/s
    """
    audio_size = audio_rate * length 
    target_size_kbits = target_size * 8
    bitrate = (target_size_kbits - audio_size) / length
    return bitrate


def generate_file_loop(generate_file_func, target_size, options):
    """
    Used by each encoder type;
    they run this loop, supplying their file generation function
    and starting target file size.
    """
    if len(sys.argv) < 2:
        print(f"usage: {sys.argv[0]} <regular ffmpeg commands>")

    input_options = options[0]
    filename_index = input_options.index("-i") + 1
    filename = input_options[filename_index]
    audio_rate = get_audio_rate(options[1])

    
    print(f"Getting file:{filename}")
    length = get_length(filename)
    print(f"File length:{length} seconds")
    print(f"Estimated audio size: {audio_rate*length/8/1024:.0f}KB")
    
    min_size, target_size, max_size = target_size
    actual_size = generate_file_loop_iter(target_size, length, generate_file_func, options)
        
    if actual_size < min_size:
        print (actual_size/min_size, actual_size, min_size)
        print(f"For some reason we got a REALLY low file size:")
        print(f"Actual: {bytes_to_mb(actual_size)}\n" +
              f"Target {kb_to_mb(target_size)}")
        target_size *= float(max_size) / (actual_size*1.02)
        print(f"New Target size: {kb_to_mb(target_size)}")
        actual_size = generate_file_loop_iter(target_size, length, generate_file_func, options)
        
        
    while actual_size > max_size:
        print(f"Uh oh, we're still over size.\n" +
              f"Actual: {bytes_to_mb(actual_size)}\n" +
              f"Target supplied: {kb_to_mb(target_size)}")
        target_size -= int(.01*max_size)
        print (f"New Target: {kb_to_mb(target_size)}")
        actual_size = generate_file_loop_iter(target_size, length, generate_file_func, options)

    print("all done:")
    print(f"Actual: {bytes_to_mb(actual_size)}\n"
        + f"Target supplied: {kb_to_mb(target_size)}")

def kb_to_mb(value):
    return value / 1024.0
    
def bytes_to_mb(value):
    return value / 1024 / 1024.0
    
def generate_file_loop_iter(target_size, length, func, options):
    """
    one loop of the file generation process
    """
    audio_rate = get_audio_rate(options[1])
    bitrate = get_bitrate(target_size, length, audio_rate)
    
    if bitrate < 0:
        print("Unfortunately there is not enough bits for video!")
        print(f"Bitrate: {bitrate}, Target: {target_size}mb")
        sys.exit()
    actual_size = func(bitrate, audio_rate, options)
    delete_logs()  # only necessary for libx264, but lets just delete it always.
    return actual_size


def main():
    """
    main function for this program
    """
    if "--check_nvidia" in sys.argv:
        has_nvidia = check_nvidia()
        print("We have NVIDIA!")
        sys.exit(0 if has_nvidia else 1)

    sys.exit(0)


if __name__ == "__main__":
    main()
